package com.redhat.contentspec.builder.utils;

import java.io.ByteArrayInputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Map.Entry;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerException;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMResult;
import javax.xml.transform.dom.DOMSource;

import org.jboss.resteasy.logging.Logger;
import org.w3c.dom.Document;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import com.google.code.regexp.NamedMatcher;
import com.google.code.regexp.NamedPattern;
import com.redhat.contentspec.utils.ExceptionUtilities;
import com.redhat.ecs.commonstructures.Pair;
import com.redhat.ecs.internalsort.EntitySubstitutionBoundaryDataBoundaryStartSort;
import com.redhat.ecs.internaltructures.EntitySubstitutionBoundaryData;

/**
 * A class that adds additional functionality to the com.redhat.ecs.commonutils.XMLUtilities class.
 */
public class XMLUtilities extends com.redhat.ecs.commonutils.XMLUtilities {
	
	private static final Logger log = Logger.getLogger(XMLUtilities.class);
	
    /**
     * Gets a XML documents encoding
     * 
     * @param input A string representing a XML document
     * @return The encoding format used in the XML document or UTF-8 in none were found
     */
    public static String getDocumentEncoding(String input) {
        String output = "utf-8";
        Pattern p = Pattern.compile("encoding[ ]*=[ ]*\".*\".*(\n)?");
        Matcher m = p.matcher(input.toLowerCase());
        if (m.find()) {
        	output = m.group();
        	output = output.substring(output.indexOf('"') + 1, output.lastIndexOf('"'));
        }
        return output;
    }
    
    /**
     * Removes all of the child nodes from a parent node.
     */
    public static void emptyNode(Node parent) {
    	NodeList childNodes = parent.getChildNodes();
		for (int i = childNodes.getLength() - 1; i >= 0; i--) {
			Node childNode = childNodes.item(i);
			childNode.getParentNode().removeChild(childNode);
		}
    }
	
    /**
     * Clones a document object.
     */
    public static Document cloneDocument(Document doc) throws TransformerException {
    	TransformerFactory tfactory = TransformerFactory.newInstance();
    	Transformer tx   = tfactory.newTransformer();
    	DOMSource source = new DOMSource(doc);
    	DOMResult result = new DOMResult();
    	tx.transform(source,result);
    	return (Document)result.getNode();
    }
    
    /**
	 * This function will return a map that contains entity names as keys, and
	 * random integer strings as values. The values are guaranteed not to have
	 * appeared in the original xml.
	 * 
	 * @param xml
	 *            The xml to generate the replacements for
	 * @return a map of entity names to unique random strings
	 */
	private static Map<String, String> calculateEntityReplacements(final String xml)
	{
		final Map<String, String> retValue = new HashMap<String, String>();

		final Random randomGenerator = new Random();

		/* compile the regular expression */
		final NamedPattern injectionSequencePattern = NamedPattern.compile(XML_ENTITY_RE);
		/* find any matches */
		final NamedMatcher injectionSequencematcher = injectionSequencePattern.matcher(xml);

		/* loop over the regular expression matches */
		while (injectionSequencematcher.find())
		{
			final String entityName = injectionSequencematcher.group(XML_ENTITY_NAMED_GROUP);

			if (!retValue.containsKey(entityName))
			{
				String randomReplacement;
				do
				{
					randomReplacement = "[" + randomGenerator.nextInt() + "]";
				}
				while (xml.indexOf(randomReplacement) != -1);

				retValue.put(entityName, randomReplacement);
			}
		}

		return retValue;
	}

	/**
	 * This function takes the Map generated by the calculateEntityReplacements
	 * function, and uses those values to replace any entities in the XML string
	 * with their unique random integer replacements. The end results is an XML
	 * string that contains no entities, but contains identifiable strings that
	 * can be used to replace those entities at a later point.
	 * 
	 * @param replacements
	 *            The Map generated by the calculateEntityReplacements function
	 * @param xml
	 *            The XML string to modify
	 * @return The modified XML
	 */
	private static String replaceEntities(final Map<String, String> replacements, final String xml)
	{
		String retValue = xml;
		for (final String entity : replacements.keySet())
			retValue = retValue.replaceAll("\\&" + entity + ";", replacements.get(entity));
		return retValue;
	}

	/**
	 * This function takes a parsed Document, along with the Map generated by
	 * the calculateEntityReplacements function, and restores all the entities.
	 * 
	 * @param replacements
	 *            The Map generated by the calculateEntityReplacements function
	 * @param node
	 *            The node to modify
	 */
	private static void restoreEntities(final Map<String, String> replacements, final Node node)
	{
		if (node == null || replacements == null || replacements.size() == 0)
			return;

		/* make the substitutions for all children nodes */
		final NodeList nodeList = node.getChildNodes();
		final int childrenCount = nodeList.getLength();
		for (int i = 0; i < childrenCount; ++i)
			restoreEntities(replacements, nodeList.item(i));

		/* cdata sections just use a straight text replace */
		if (node.getNodeType() == Node.CDATA_SECTION_NODE)
		{
			for (final Entry<String, String> entityReplacement : replacements.entrySet())
			{
				final String entity = "&" + entityReplacement.getKey() + ";";
				final String markerAsRE = entityReplacement.getValue().replace("[", "\\[").replace("]", "\\]");
				final String textContent = node.getTextContent();
				final String fixedTextContent = textContent.replaceAll(markerAsRE, entity);
				node.setTextContent(fixedTextContent);
			}
		}
		else if (node.getNodeType() == Node.TEXT_NODE)
		{
			/* The list of substitution string boundaries */
			final List<EntitySubstitutionBoundaryData> boundaries = new ArrayList<EntitySubstitutionBoundaryData>();

			/*
			 * find the start and end indexes of all the substitutions in this
			 * text node
			 */
			for (final Entry<String, String> entityReplacement : replacements.entrySet())
			{
				final String entityName = entityReplacement.getKey();
				final String entityPlaceholder = entityReplacement.getValue();

				/* The length of the placeholder string */
				final int entityPlaceholderLength = entityPlaceholder.length();
				/* The text in this node, with the substitutions */
				final String originalText = node.getTextContent();

				int startIndex = 0;
				while ((startIndex = originalText.indexOf(entityPlaceholder, startIndex)) != -1)
				{
					boundaries.add(new EntitySubstitutionBoundaryData(entityName, entityPlaceholder, new Pair<Integer, Integer>(startIndex, startIndex + entityPlaceholderLength - 1)));
					startIndex += entityPlaceholderLength;
				}
			}

			/*
			 * if there are no boundaries, there is no need to do any
			 * substitutions
			 */
			if (boundaries.size() != 0)
			{
				/* Sort based on the start of the boundaries */
				Collections.sort(boundaries, new EntitySubstitutionBoundaryDataBoundaryStartSort());

				/* get the text content of the text node */
				final String originalText = node.getTextContent();

				/* the parent of this node holds only this text node. */
				final Node parentNode = node.getParentNode();

				/*
				 * loop through all the boundaries that define the position of
				 * the substitutions, and replace them with entity reference
				 * nodes.
				 * 
				 * this involves adding a new sequence of text and entity
				 * reference nodes before the existing text node, and then
				 * removing the existing text node.
				 */
				for (int i = 0; i < boundaries.size(); ++i)
				{
					final EntitySubstitutionBoundaryData boundary = boundaries.get(i);
					final EntitySubstitutionBoundaryData lastBoundary = i != 0 ? boundaries.get(i - 1) : null;

					/* the entity node */
					final Node entityNode = parentNode.getOwnerDocument().createEntityReference(boundary.getEntityName());

					/* the first substitution where text proceeds it */
					if (i == 0)
					{
						if (boundary.getBoundary().getFirst() != 0)
						{
							final Node textNode = parentNode.getOwnerDocument().createTextNode(originalText.substring(0, boundary.getBoundary().getFirst()));
							parentNode.insertBefore(textNode, node);
						}

						/* append an entity node after the initial text node */
						parentNode.insertBefore(entityNode, node);
					}
					else
					{
						/*
						 * there is a gap between the last boundary and this
						 * boundary
						 */

						if (lastBoundary.getBoundary().getSecond() + 1 != boundary.getBoundary().getFirst())
						{
							final Node textNode = parentNode.getOwnerDocument().createTextNode(originalText.substring(lastBoundary.getBoundary().getSecond() + 1, boundary.getBoundary().getFirst()));
							parentNode.insertBefore(textNode, node);
						}
					}

					/*
					 * append an entity node after the text node following the
					 * last substitution
					 */
					parentNode.insertBefore(entityNode, node);

					/* the last substitution where text follows it */
					if (i == boundaries.size() - 1)
					{
						/* append an entity node before the last text node */
						parentNode.insertBefore(entityNode, node);

						if (boundary.getBoundary().getSecond() != originalText.length() - 1)
						{
							final Node textNode = parentNode.getOwnerDocument().createTextNode(originalText.substring(boundary.getBoundary().getSecond() + 1));
							parentNode.insertBefore(textNode, node);
						}
					}
				}

				/* finally, remove the existing text node */
				parentNode.removeChild(node);
			}

		}

		// TODO: deal with entities in attributes
	}

	/**
	 * @param xml
	 *            The XML to be converted
	 * @return A Document converted from the supplied XML, or null if the
	 *         supplied XML was invalid
	 */
	public static Document convertStringToDocument(final String xml)
	{
		if (xml == null)
			return null;

		try
		{
			// find the encoding, defaulting to UTF-8
			String encoding = findEncoding(xml);
			if (encoding == null)
				encoding = "UTF-8";

			/*
			 * Xerces does not seem to have any way of simply importing entities
			 * "as is". It will try to expand them, which we don't want. As a
			 * work around the calculateEntityReplacements() function will map
			 * entity names to random substitution markers. These markers are
			 * parsed as plain text (they are in the format "[random_integer]").
			 * The replaceEntities() function will then replace the entity
			 * definitions in the source XML text with these substitution
			 * markers.
			 * 
			 * At this point the XML has no entities, and so Xerces will parse
			 * the string without trying to expand the entities.
			 * 
			 * Once we have a Document object, we run the restoreEntities()
			 * function, which replaces the substitution markers with entity
			 * reference nodes. Xerces does not try to expand entites when
			 * serializing a Document object to a string, nor does it try to
			 * extand entity reference nodes when they are added. In this way we
			 * can parse any XML and retain the entities without having to link
			 * to any DTDs or implement any EntityResolvers.
			 */
			final Map<String, String> replacements = calculateEntityReplacements(xml);
			final String fixedXML = replaceEntities(replacements, xml);

			final DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
			builderFactory.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
			builderFactory.setValidating(false);

			final DocumentBuilder builder = builderFactory.newDocumentBuilder();
			final Document document = builder.parse(new ByteArrayInputStream(fixedXML.getBytes(encoding)));

			restoreEntities(replacements, document.getDocumentElement());

			return document;
		}
		catch (Exception ex)
		{
			log.debug(ExceptionUtilities.getStackTrace(ex));
		}

		return null;
	}
}
